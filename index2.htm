<!DOCTYPE html>
<html>
<head>
<title>Title of the document</title>
<script src="alertify/js/alertify.js"></script>
<link href="alertify/css/core.css" rel="stylesheet" type="text/css"></link>
<link href="alertify/css/themes/default/default.css" rel="stylesheet" type="text/css"></link>

<script src="https://cdnjs.cloudflare.com/ajax/libs/knockout/3.3.0/knockout-min.js"></script>
<script src="https://code.jquery.com/jquery-2.1.3.min.js"></script>
<script>
var Skill = {
	Pistols: "Pistols",
	Automatics: "Automatics",
	LongArms: "LongArms"
};

var FireModeEnum = function(name, bulletsUsed, defenseMod, causesProgressiveRecoil) {
	var self = this;
	self.name = name;
	self.bulletsUsed = bulletsUsed;
	self.defenseMod = defenseMod;
	self.causesProgressiveRecoil = causesProgressiveRecoil;
}

var FireMode = {
	SS: new FireModeEnum("SS", 1, 0, false),
	SA: new FireModeEnum("SA", 1, 0, false),
	SB: new FireModeEnum("SB", 3, -2, true),
	BF: new FireModeEnum("BF", 3, -2, false),
	FA: new FireModeEnum("FA", 10, -9, true),
	asArray: function() {
		var arr = [];
		for (var x in this) {
			if (typeof this[x] == "object") {
				arr.push(this[x]);
			}
		}
		return arr;
	}
}

var StatusEnum = function(key, attackMod, defenseMod) {
	var self = this;
	self.key = key;
	self.attackMod = attackMod;
	self.defenseMod = defenseMod;
};

var Status = {
	BlindFire: new StatusEnum("BlindFire", -6, 0),
	BlindFireWithImaging: new StatusEnum("BlindFireWithImaging", -3, 0),
	CalledShot: new StatusEnum("CalledShot", -4, 0),
	Charging: new StatusEnum("Charging", 2, 0),
	FriendsInMelee: new StatusEnum("FriendsInMelee", 1, 0),
	GoodCover: new StatusEnum("GoodCover", 0, 4),
	ImplantedSmartGun: new StatusEnum("ImplantedSmartGun", 2, 0),
	InMelee: new StatusEnum("InMelee", -3, -3),
	InMovingVehicle: new StatusEnum("InMovingVehicle", 0, 3),
	PartialCover: new StatusEnum("PartialCover", 0, 2),
	Prone: new StatusEnum("Prone", -1, -2),
	ReceivingCharge: new StatusEnum("ReceivingCharge", 0, 1),
	Running: new StatusEnum("Running", -2, 2),
	SmartGun: new StatusEnum("SmartGun", 1, 0),
	SuperiorPosition: new StatusEnum("SuperiorPosition", 2, 0),
	TouchOnly: new StatusEnum("TouchOnly", 2, 0),
	attackModifiers: function() {
		var arr = [];
		for (var x in this) {
			if (typeof this[x] == "object") {
				if (this[x].attackMod != 0) {
					arr.push(this[x]);
				}
			}
		}
		return arr;
	},
	defenseModifiers: function() {
		var arr = [];
		for (var x in this) {
			if (typeof this[x] == "object") {
				if (this[x].defenseMod != 0) {
					arr.push(this[x]);
				}
			}
		}
		return arr;
	},
};

function Initiative(modifier, bonusDice) {
	var self = this;
	self.modifier = modifier;
	self.bonusDice = bonusDice;
	self.score = ko.observable(0);
	self.label = ko.computed(function() { return self.score() + '(' + self.modifier + '+' + self.bonusDice + 'd6)' });
	self.roll = function() {
		self.score(self.modifier + rollSum(self.bonusDice));
	};
	self.drop = function(score) {
		self.score(self.score() - score);
	};
}

function Npc(name, body, agility, reaction, strength, willpower, logic, intuition, charisma, edge, magic, essence, armor, skills, guns, bonusInitiativeDice) {
	var self = this;
	self.name = name;
	self.body = body;
	self.agility = agility;
	self.reaction = reaction;
	self.strength = ko.observable(strength);
	self.willpower = willpower;
	self.logic = logic;
	self.intuition = intuition;
	self.charisma = charisma;
	self.edge = edge;
	self.magic = magic;
	self.essence = essence;
	self.armor = armor;
	self.recoilCompensation = ko.computed(function() { return Math.ceil(self.strength() / 3) + 1; });
	self.meleeWeapons = ko.observableArray([]);
	self.skills = skills;
	self.statuses = ko.observableArray([]);
	self.initiative = ko.computed(function() { 
		return new Initiative(self.reaction + self.intuition, bonusInitiativeDice); 
	});
	self.isActive = ko.observable(false);

	var sumModifiers = function(prop) {
		var sum = 0;
		for (var i = 0; i < self.statuses().length; i++) {
			for (var x = 0; x < arguments.length; x++) {
				if (self.statuses()[i] == arguments[x]) {
					sum += self.statuses()[i][prop];
				}
			}
		}
		return sum;
	};

	self.damageBoxes = ko.observable(0);
	self.conditionMonitor = ko.computed(function() { return Math.ceil(self.body / 2) + 8; });
	self.undamagedBoxes = ko.computed(function() { return self.conditionMonitor() - self.damageBoxes(); });
	self.conditionModifier = ko.computed(function() { return -Math.floor(self.damageBoxes() / 3); });
	self.lowerCondition = function() { if (self.damageBoxes() < self.conditionMonitor()) self.damageBoxes(self.damageBoxes() + 1); };
	self.raiseCondition = function() { if (self.damageBoxes() > 0) self.damageBoxes(self.damageBoxes() - 1); };

	self.miscDefenseMod = ko.observable(0);
	self.lowerDefense = function() { self.miscDefenseMod(self.miscDefenseMod() - 1); };
	self.raiseDefense = function() { self.miscDefenseMod(self.miscDefenseMod() + 1); };
	self.previouslyDefendedAttacks = ko.observable(0);
	self.defense = ko.computed(function() { return self.reaction + self.intuition + self.miscDefenseMod() + self.conditionModifier() - self.previouslyDefendedAttacks(); });
	self.gunDefense = ko.computed(function() {
		return self.defense() + 
			sumModifiers("defenseMod",
				Status.InMovingVehicle,
				Status.Prone,
				Status.Running,
				Status.GoodCover,
				Status.PartialCover,
				Status.InMelee);
	});
	self.meleeDefense = ko.computed(function() {
		return self.defense() + 
			sumModifiers("defenseMod",
				Status.InMovingVehicle,
				Status.ReceivingCharge,
				Status.GoodCover,
				Status.PartialCover);
	});

	var DefenseFireMode = function(mode) {
		var self2 = this;
		self2.mode = mode;
		self2.modifier = ko.computed(function() {
			return self.gunDefense() + self2.mode.defenseMod;
		});
		self2.label = ko.computed(function() {
			return self2.mode.name + ' ' + self2.modifier() + '(' + self2.mode.defenseMod + ')';
		});
	};
	self.defenseFireModes = ko.observableArray([]);
	var fireModes = FireMode.asArray();
	for (var i in fireModes) {
		self.defenseFireModes.push(new DefenseFireMode(fireModes[i]));
	}

	self.resistanceMiscModifier = ko.observable(0);
	self.resistance = ko.computed(function() { return self.armor + self.body + self.resistanceMiscModifier(); });
	self.lowerResistance = function() { self.resistanceMiscModifier(self.resistanceMiscModifier() - 1); };
	self.raiseResistance = function() { self.resistanceMiscModifier(self.resistanceMiscModifier() + 1); };

	self.progressiveRecoil = ko.observable(0);
	self.resetRecoil = function() {
		self.progressiveRecoil(0);
	};

	self.statusModifier = function(status, modifier) {
		for (var i = 0; i < self.statuses().length; i++) {
			if (self.statuses()[i] == status)
				return modifier ? modifier : status.value;
		}
	};

	self.rangedAttackStatusModifier = ko.computed(function() {
		return sumModifiers("attackMod",
			Status.BlindFire,
			Status.BlindFireWithImaging,
			Status.InMelee,
			Status.Running,
			Status.CalledShot,
			Status.SmartGun,
			Status.ImplantedSmartGun);
	});

	self.meleeAttackModifiers = ko.computed(function() {
		return sumModifiers("attackMod",
			Status.Charging,
			Status.Prone,
			Status.CalledShot,
			Status.SuperiorPosition,
			Status.FriendsInMelee,
			Status.TouchOnly);
	});

	self.toggleDefenseModifier = function(modifier) {
		if (self.statuses.indexOf(modifier) != -1) {
			self.statuses.remove(modifier);
			return false;
		}
		self.statuses.push(modifier);
		return true;
	};

	self.shoot = function(gun, fireMode) {
		var dicePool = fireMode.modifier();
		if (fireMode.mode.causesProgressiveRecoil) {
			self.progressiveRecoil(self.progressiveRecoil() + fireMode.mode.bulletsUsed);
		}

		gun.usedAmmo(gun.usedAmmo() + fireMode.mode.bulletsUsed);

		return dicePool;
	};

	self.melee = function(weapon) {
		var dicePool = self.agility + 
			self.skills[weapon.linkedSkill] + 
			self.conditionModifier() + 
			self.meleeAttackModifiers();

	};

	self.gunDefend = function(fireMode) {
		var dicePool = fireMode.modifier();
		self.previouslyDefendedAttacks(self.previouslyDefendedAttacks() + 1);
		return dicePool;
	};

	self.meleeDefend = function() {
		var dicePool = self.meleeDefense();
		self.previouslyDefendedAttacks(self.previouslyDefendedAttacks() + 1);
		return dicePool;
	};

	self.addGun = function(gun) {
		self.guns.push(gun);
		gun.setNpc(self);
	};

	self.guns = ko.observableArray([]);
	self.addGun = function(gun) {
		self.guns.push(gun);
		gun.setNpc(self);
	};
	for (var i in guns) {
		self.addGun(guns[i]);
	}

	self.clone = function() {
		var guns = [];
		for (var i in self.guns()) {
			guns.push(self.guns()[i].clone());
		}
		return new Npc(name, body, agility, reaction, strength, willpower, logic, intuition, charisma, edge, magic, essence, armor, skills, guns, bonusInitiativeDice);
	};

	self.cloneMany = function(count) {
		var npcs = [];
		for (var i = 1; i <= count; i++) {
			var npc = self.clone();
			npc.name = npc.name.replace(/\{0\}/, i);
			npcs.push(npc);
		}
		return npcs;
	};
}

function Gun(name, accuracy, damage, damageType, armorPenetration, fireModes, recoilCompensation, maxAmmo, linkedSkill) {
	var self = this;
	self.name = name;
	self.accuracy = accuracy;
	self.damage = damage;
	self.damageType = damageType;
	self.armorPenetration = armorPenetration;
	self.recoilCompensation = recoilCompensation;
	self.maxAmmo = maxAmmo;
	self.usedAmmo = ko.observable(0);
	self.ammo = ko.computed(function() { return self.maxAmmo - self.usedAmmo(); });
	self.reload = function() {
		self.usedAmmo(0);
	};
	self.deviceRating = 2;
	self.linkedSkill = linkedSkill;
	self.miscModifier = ko.observable(0);

	self.clone = function() {
		return new Gun(name, accuracy, damage, damageType, armorPenetration, fireModes, recoilCompensation, maxAmmo, linkedSkill);
	};

	self.raiseMiscModifier = function() { self.miscModifier(self.miscModifier() + 1); };
	self.lowerMiscModifier = function() { self.miscModifier(self.miscModifier() - 1); };

	self.setNpc = function(npc) {
		self.modifier = ko.computed(function() {
			return npc.agility + 
				npc.skills[self.linkedSkill] + 
				npc.conditionModifier() + 
				npc.rangedAttackStatusModifier() +
				self.miscModifier();
		});

		self.totalRecoilCompensation = ko.computed(function() { return npc.recoilCompensation() + self.recoilCompensation; });
		self.progressiveRecoil = ko.computed(function() { return self.totalRecoilCompensation() - npc.progressiveRecoil(); });
		self.recoilLabel = ko.computed(function() { return self.progressiveRecoil() + ' ' + (self.progressiveRecoil() >= 0 ? 'rc' : 'pr'); });

		var GunFireMode = function(mode) {
			var self2 = this;
			self2.mode = mode;
			self2.modifier = ko.computed(function() {
				var recoilCompensation = self2.mode.causesProgressiveRecoil ? self.progressiveRecoil() : self.totalRecoilCompensation();
				var progressiveRecoil = recoilCompensation - self2.mode.bulletsUsed;
				if (progressiveRecoil >= 0) return self.modifier();
				return self.modifier() + progressiveRecoil;
			});
		};
		self.fireModes = ko.observableArray([]);
		for (var i in fireModes) {
			self.fireModes.push(new GunFireMode(fireModes[i]));
		}
	};
}

//function Gun(name, accuracy, damage, damageType, armorPenetration, fireModes, recoilCompensation, maxAmmo, linkedSkill) {
var Guns = {
	AresPredatorV: function () { return new Gun('Ares Predator V', 5, 8, 'P', -1, [FireMode.SA,FireMode.SB], 0, 15, Skill.Pistols); },
	BrowningUltraPower: function () { return new Gun('Browning Ultra-Power', 6, 8, 'P', -1, [FireMode.SA,FireMode.SB], 0, 10, Skill.Pistols); },
	RugerSuperWarhawk: function () { return new Gun('Ruger Super Warhawk', 5, 9, 'P', -2, [FireMode.SS], 0, 6, Skill.Pistols); },
	ColtGovernment2066: function () { return new Gun('Colt Government 2066', 6, 7, 'P', -1, [FireMode.SA,FireMode.SB], 0, 14, Skill.Pistols); },
	ColtCobraTZ120: function () { return new Gun('Colt Cobra TZ-120', 5, 7, 'P', 0, [FireMode.SA,FireMode.BF,FireMode.FA], 3, 32, Skill.Automatics); },
	AK97: function () { return new Gun('AK-97', 5, 10, 'P', -2, [FireMode.SA,FireMode.BF,FireMode.FA], 0, 38, Skill.Automatics); },
	Bow: function (rating) { return new Gun('Bow ' + rating, 6, rating + 2, 'P', -Math.ceil(rating / 4), [FireMode.SS], 0, 99, Skill.Automatics); },
	DefianceT250: function () { return new Gun('Defiance T-250', 4, 10, 'P', -1, [FireMode.SS,FireMode.SA,FireMode.SB], 0, 5, Skill.LongArms); },
};

var log = function(success, msg) {
	if (success !== true && success !== false) {
		msg = success;
		success = true;
	}

	if (success) alertify.success(msg);
	else alertify.error(msg);

	console.log(msg.replace("<br/>", "\r\n"));
};

function AppViewModel() {
	var self = this;

//function Npc(name, body, agility, reaction, strength, willpower, logic, intuition, charisma, edge, magic, essence, armor, skills, guns) {
//function Gun(name, accuracy, damage, damageType, armorPenetration, fireModes, recoilCompensation, maxAmmo, linkedSkill) {

	var skillSet = {};
	skillSet[Skill.Pistols] = 5;
	skillSet[Skill.Automatics] = 5;
	var shooters = new Npc('Shooters Ganger {0}', 4, 5, 5, 3, 3, 3, 3, 5, 3, 0, 5, 8, skillSet, 
		[Guns.BrowningUltraPower(), Guns.ColtCobraTZ120()], 1).cloneMany(11);

	var skillSet = {};
	skillSet[Skill.Pistols] = 6;
	var shootersLeader = new Npc('"Enyo" Leader', 5, 9, 7, 3, 4, 4, 4, 8, 3, 0, 2.73, 8, skillSet, 
		[Guns.BrowningUltraPower()], 1);

	var skillSet = {};
	skillSet[Skill.Pistols] = 5;
	skillSet[Skill.Automatics] = 5;
	var spans = new Npc('Span Ganger {0}a', 6, 5, 4, 6, 3, 2, 3, 3, 3, 0, 5, 9, skillSet, 
		[Guns.ColtGovernment2066()], 1).cloneMany(4);
	spans = spans.concat(new Npc('Span Ganger {0}b', 6, 5, 4, 6, 3, 2, 3, 3, 3, 0, 5, 9, skillSet, 
		[Guns.AK97()]).cloneMany(4));

	var skillSet = {};
	skillSet[Skill.Pistols] = 6;
	var spansLeader = new Npc('"The Duke" Leader', 7, 8, 6, 9, 4, 3, 3, 4, 3, 0, 0.8, 15, skillSet, 
		[Guns.RugerSuperWarhawk()], 3);

	var skillSet = {};
	skillSet[Skill.Pistols] = 4;
	skillSet[Skill.Automatics] = 6;
	var dogSoldiers = new Npc('Dog Soldiers {0}', 4, 6, 4, 7, 3, 3, 3, 3, 3, 0, 5, 9, skillSet, 
		[Guns.ColtGovernment2066(), Guns.Bow(7)], 1).cloneMany(11);

	var dogSoldiersLeader = new Npc('"Red Feather" Leader', 5, 6, 8, 5, 4, 4, 4, 4, 3, 6, 6, 11, {}, [], 4);

	var skillSet = {};
	skillSet[Skill.Pistols] = 5;
	skillSet[Skill.LongArms] = 5;
	var gimliSons = new Npc('Gimli Sons {0}', 6, 5, 4, 7, 3, 3, 3, 3, 3, 0, 5, 9, skillSet, 
		[Guns.ColtGovernment2066(), Guns.DefianceT250()], 1).cloneMany(9);

	var skillSet = {};
	skillSet[Skill.Pistols] = 6;
	var gimliSonsLeader = new Npc('"Stump" Leader', 6, 5, 5, 7, 6, 4, 5, 4, 3, 6, 6, 9, skillSet, 
		[Guns.ColtGovernment2066()], 2);

	var npcs = [];
	if (location.href.indexOf('shooters') != -1) npcs = shooters.concat([shootersLeader]);
	else if (location.href.indexOf('spans') != -1) npcs = spans.concat([spansLeader]);
	else if (location.href.indexOf('dogsoldiers') != -1) npcs = dogSoldiers.concat([dogSoldiersLeader]);
	else if (location.href.indexOf('gimlisons') != -1) npcs = gimliSons.concat([gimliSonsLeader]);

	var skillSet = {};
	skillSet[Skill.Pistols] = 3;
	var pcs = [
		new Npc('Ben', 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, {}, [], 1),
		new Npc('Ben HotSim', 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, {}, [], 4),
		new Npc('Ben ColdSim', 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, {}, [], 3),
		new Npc('Adam', 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, {}, [], 3),
		new Npc('Bill', 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, {}, [], 1),
		new Npc('Jim', 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, {}, [], 1),
		new Npc('Jim HotSim', 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, {}, [], 4),
		new Npc('Jim ColdSim', 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, {}, [], 3),
		new Npc('Aaron', 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, {}, [], 1)
	];

	self.npcs = ko.observableArray(npcs.concat(pcs));

	self.attackModifiers = Status.attackModifiers();
	self.defenseModifiers = Status.defenseModifiers();
	self.fireModes = FireMode.asArray();
	self.actingCharacter = 0;

	var generalOutput = function(desc, diceResult) {
		if (diceResult.glitch) {
			log(false, desc + '. Glitch.<br/>' + diceResult.dice + ' dice / ' + diceResult.hits + ' hits');
		}
		else {
			log(desc + '<br/>' + diceResult.dice + ' dice / ' + diceResult.hits + ' hits');
		}
	};

	self.startCombatTurn = function() {
		log("Starting new combat turn");
		self.npcs()[self.actingCharacter].isActive(false);
		for (var i in self.npcs()) {
			self.npcs()[i].initiative().roll();
		}
		self.npcs.sort(function(a, b) {
			if (a.initiative().score() > b.initiative().score()) return -1;
			if (a.initiative().score() < b.initiative().score()) return 1;
			return 0;
		});
		self.actingCharacter = 0;
		self.npcs()[self.actingCharacter].isActive(true);
	};
	self.startCombatTurn();

	var endInitiativePass = function() {
		for (var i in self.npcs()) {
			var npcInitiative = self.npcs()[i].initiative();
			npcInitiative.score(npcInitiative.score() - 10);
		}
	};

	self.endTurn = function() {
		self.npcs()[self.actingCharacter].isActive(false);
		var next = -1;
		var i = self.actingCharacter + 1;
		for (var limiter = self.npcs().length; limiter > 0; limiter--, i++) {
			if (i >= self.npcs().length) {
				endInitiativePass();
				i = 0;
			}
			if (self.npcs()[i].initiative().score() > 0) {
				next = i;
				break;
			}
		}
		if (next == -1) {
			self.startCombatTurn();
		}
		else {
			self.actingCharacter = next;
			self.npcs()[self.actingCharacter].isActive(true);
		}
	}

	self.rollGunDefense = function(npc, fireMode) {
		var dicePool = npc.gunDefend(fireMode);
		generalOutput('Defense', roll(dicePool));
	};

	self.rollMeleeDefense = function(npc) {
		var dicePool = npc.meleeDefend();
		generalOutput('Defense', roll(dicePool));
	};

	self.rollResistance = function(npc) {
		generalOutput('Resistance', roll(npc.resistance()));
	};

	self.shoot = function(npc, gun, mode) {
		var diceResults = roll(npc.shoot(gun, mode));
		generalOutput(gun.name + ' ' + mode.mode.name, diceResults);
	};

	self.rollMeleeWeapon = function(npc, meleeWeapon) {
		generalOutput(meleeWeapon.name + ' Attack', roll(meleeWeapon.dicePool - npc.conditionModifier()));
		log(meleeWeapon.dmg + ' DV ' + meleeWeapon.ap + ' AP');		
	};

	self.toggleDefenseModifier = function(npc, modifier, event) {
		var $target = $(event.target);

		if (npc.toggleDefenseModifier(modifier)) {
			$target.addClass('on');
		}
		else {
			$target.removeClass('on');
		}
	}
}

function rollSum(dice) {
	var sum = 0;
	for (var i = 0; i < dice; i++) {
		sum += Math.floor((Math.random() * 6) + 1);
	}
	return sum;
}

function roll(dice) {
	var dice = dice < 0 ? 0 : dice;
	var hits = 0;
	var ones = 0;
	for (var i = 0; i < dice; i++) {
		var result = Math.floor((Math.random() * 6) + 1);
		if (result < 1 || result > 6) alert (result);
		if (result == 1) ones++;
		if (result >= 5) hits++;
	}
	if (ones > dice / 2) {
		return { dice: dice, glitch: true, hits: hits };
	}
	return { dice: dice, hits: hits };
}

// Activates knockout.js
$(function() {
	ko.applyBindings(new AppViewModel());
});
</script>
<style type="text/css">
.npc {
	float: left;
	border: 1px solid black;
	margin: 5px;
	padding: 5px;
	position: relative;
	width: 700px;
	height:300px;
}
.action-grp {
	margin: 5px 0;
	clear: both;
}
.npc .name {
	margin: 0 0 10px 0;
}
.modifier {
	padding:2px 5px;
	border:0;
	background-color: lightgray;
	width: 22%;
	margin-right: 1%;
	display: block;
	float: left;
	margin-top: 4px;
}
.on {
	font-weight: bold;
}
br {
	clear: both;
}
button.fixed-wide {
	width: 75px;
}
.end-turn {
	position: absolute;
	right: 10px;
	top: 10px;
}
.active {
	background-color: #F0FFF0;
}
</style>
</head>

<body>
<div>
	<button data-bind="click: startCombatTurn">New Combat Turn</button>
</div>
<div data-bind="foreach: npcs">
	<div class="npc" data-bind="css: { active: isActive }">
		<h1 class="name"><span data-bind="text: name"></span>, <span data-bind="text: initiative().label()"></span></h1>
		<div class="end-turn">
			<button data-bind="click: function() { initiative().drop(5); }">-5</button>
			<button data-bind="click: function() { initiative().drop(10); }">-10</button>
			<button data-bind="click: $root.endTurn">End Turn</button>
		</div>
		<div class="action-grp">
			<button data-bind="text: 'Condition Monitor ' + undamagedBoxes(), event: {contextmenu: raiseCondition}, click: lowerCondition"></button>
		</div>
<!-- defense -->
		<div class="action-grp">
			<button data-bind="text: 'Defense ' + defense() + '(' + miscDefenseMod() + ')', event: {contextmenu: lowerDefense}, click: raiseDefense"></button>
			<span data-bind="foreach: defenseFireModes" class="action-grp">
				<button class="fixed-wide" data-bind="text: label, click: function() { $root.rollGunDefense($parent, $data); }"></button>
			</span>
			<button data-bind="text: 'Melee ' + meleeDefense(), click: $root.rollMeleeDefense"></button>
		</div>
<!-- defense mods -->
		<div data-bind="foreach: $root.defenseModifiers" class="action-grp">
			<button data-bind="text: $data.key + ' ' + $data.defenseMod, css: { on: false }, click: function(data, evt) { return $root.toggleDefenseModifier($parent, data, evt); }" class="modifier"></button>
		</div>
		<br />
<!-- resistance -->
		<div class="action-grp">
			<button data-bind="text: 'Physical Resistance ' + resistance() + '(' + resistanceMiscModifier() + ')', 
				event: {contextmenu: lowerResistance}, click: raiseResistance"></button>
			<button data-bind="text: 'Resist Physical', click: $root.rollResistance"></button>
<!--
			<button data-bind="text: 'Resist Magical ' + resistance() + '(' + resistanceMiscModifier() + ')', 
				event: {contextmenu: lowerResistance}, click: raiseResistance"></button>
			<button data-bind="text: 'Resist Magical'"></button>
-->
		</div>
<!-- guns -->
		<div class="action-grp" data-bind="foreach: guns">
			<div class="action-grp">
				<button data-bind="text: name + ' ' + modifier() + '(' + miscModifier() + ')', click: raiseMiscModifier, event: { contextmenu: lowerMiscModifier }"></button>
				<span data-bind="foreach: fireModes">
					<button class="fixed-wide" data-bind="text: mode.name + ' ' + modifier(), click: function() { $root.shoot($parents[1], $parent, $data); }"></button> 
				</span>
				<button data-bind="text: recoilLabel, click: $parent.resetRecoil"></button>
				<button data-bind="text: ammo() + ' ammo', click: reload"></button>
			</div>
		</div>
<!-- melee -->
		<div data-bind="foreach: meleeWeapons">
			<div class="action-grp">
				<span data-bind="text: name"></span> 
				<button data-bind="click: function(meleeWeapon) { $root.rollMeleeWeapon($parent, meleeWeapon); }">Attack</button> 
			</div>
		</div>
<!-- attack mods -->
		<div data-bind="foreach: $root.attackModifiers" class="action-grp">
			<button data-bind="text: $data.key + ' ' + $data.attackMod, css: { on: false }, click: function(data, evt) { return $root.toggleDefenseModifier($parent, data, evt); }" class="modifier"></button> 
		</div>
	</div>
</div>
</body>

</html>