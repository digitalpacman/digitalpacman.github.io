<!DOCTYPE html>
<html>
<head>
<title>Title of the document</title>
<script src="https://code.jquery.com/jquery-2.1.3.min.js"></script>
<script src="scrollTo/jquery.scrollTo.min.js"></script>
<script src="alertify/js/alertify.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/knockout/3.3.0/knockout-min.js"></script>
<script src="knockout.mapping-latest.js"></script>
<script src="lz-string.min.js"></script>


<link href="alertify/css/core.css" rel="stylesheet" type="text/css"></link>
<link href="alertify/css/themes/default/default.css" rel="stylesheet" type="text/css"></link>

<link href="view.css" type="text/css" rel="stylesheet"></link>

<script>

ko.observableIncremental = function(val, min, max) {
	var observable = ko.observable(val);
	observable.raise = function() { if (max == undefined || observable() < max) observable(observable() + 1); };
	observable.lower = function() { if (min == undefined || observable() > min) observable(observable() - 1); };
	return observable;
};

ko.computedResetable = function(maxComputed, min, max) {
	var limit = ko.computed(maxComputed);
	var used = ko.observableIncremental(0, min, max);
	var computed = ko.computed(function() { return limit() - used() }, 0);
	computed.used = used;
	computed.limit = limit;
	return computed;
};

function SkillArray(data) {
	var self = this;
	self.pistols = data.pistols || 0;
	self.automatics = data.automatics || 0;
	self.longArms = data.longArms || 0;
	self.blades = data.blades || 0;
	self.unarmed = data.unarmed || 0;
	self.counterSpelling = data.counterSpelling || 0;
	self.spellcasting = data.spellcasting || 0;
	self.clubs = data.clubs || 0;
}

var FireModeEnum = function(name, bulletsUsed, defenseMod, causesProgressiveRecoil) {
	var self = this;
	self.name = name;
	self.bulletsUsed = bulletsUsed;
	self.defenseMod = defenseMod;
	self.causesProgressiveRecoil = causesProgressiveRecoil;
}

var FireMode = {
	SS: new FireModeEnum("SS", 1, 0, false),
	SA: new FireModeEnum("SA", 1, 0, false),
	SB: new FireModeEnum("SB", 3, -2, true),
	BF: new FireModeEnum("BF", 3, -2, false),
	FA: new FireModeEnum("FA", 10, -9, true),
	asArray: function() {
		var arr = [];
		for (var x in this) {
			if (typeof this[x] == "object") {
				arr.push(this[x]);
			}
		}
		return arr;
	}
}

var StatusEnum = function(key, attackMod, defenseMod) {
	var self = this;
	self.key = key;
	self.attackMod = attackMod;
	self.defenseMod = defenseMod;
};

var Status = {
	BlindFire: new StatusEnum("Blind-Fire", -6, 0),
	BlindFireWithImaging: new StatusEnum("Blind-Fire With Imaging", -3, 0),
	CalledShot: new StatusEnum("Called Shot", -4, 0),
	Charging: new StatusEnum("I'm Charging", 2, 0),
	FriendsInMelee: new StatusEnum("Friends In Melee", 1, 0),
	GoodCover: new StatusEnum("I've Good Cover", 0, 4),
	InMelee: new StatusEnum("I'm In Melee", -3, -3),
	InMovingVehicle: new StatusEnum("In Moving Vehicle", 0, 3),
	LaserSight: new StatusEnum("Laser Sight", 1, 0),
	PartialCover: new StatusEnum("Partial Cover", 0, 2),
	Prone: new StatusEnum("I'm Prone", -1, -2),
	ReceivingCharge: new StatusEnum("Receiving Charge", 0, 1),
	Running: new StatusEnum("I'm Running", -2, 2),
	SuperiorPosition: new StatusEnum("Superior Position", 2, 0),
	TouchOnly: new StatusEnum("Touch Only", 2, 0),
	attackModifiers: function() {
		var arr = [];
		for (var x in this) {
			if (typeof this[x] == "object") {
				if (this[x].attackMod != 0) {
					arr.push(this[x]);
				}
			}
		}
		return arr;
	},
	defenseModifiers: function() {
		var arr = [];
		for (var x in this) {
			if (typeof this[x] == "object") {
				if (this[x].defenseMod != 0) {
					arr.push(this[x]);
				}
			}
		}
		return arr;
	},
};

function Initiative(reaction, intuition, bonusDice, dataProcessing, conditionModifier) {
	var self = this;
	self.bonusDice = ko.observable(bonusDice);
	self.modes = { 'AR': Math.min(1 + self.bonusDice(), 5), 'ColdSim VR': 3, 'HotSim VR': 4 };
	self.mode = ko.observable('AR');
	self.arModifier = ko.computed(function() { return reaction() + intuition() });
	self.vrModifier = ko.computed(function() { return dataProcessing() + intuition() });
	self.modifier = ko.computed(function() { return self.mode() == 'AR' ? self.arModifier() : self.vrModifier() });
	self.otherModes = ko.computed(function() {
		var otherModes = [];
		for (var i in self.modes) {
			if (i != self.mode())
				otherModes.push(i);
		}
		return otherModes;
	});
	self.dice = ko.computed(function() {
		return self.modes[self.mode()];
	});
	self.rolledScore = ko.observable(0);
	self.score = ko.computed(function() { return self.modifier() + self.rolledScore() + conditionModifier(); });
	self.label = ko.computed(function() { return self.score() + ' (' + self.modifier() + '+' + self.dice() + 'd6)' });
	self.roll = function() {
		var score = rollSum(self.dice());
		self.rolledScore(score);
	};
	self.hotSimModifier = ko.computed(function() {
		return self.mode() == 'HotSim VR'  ? 2 : 0;
	});
	self.changeScore = function(score) {
		self.rolledScore(self.rolledScore() + score);
	};
	self.changeMode = function(mode) {
		var diceDiff = self.modes[mode] - self.dice();
		if (diceDiff != 0) {
			var dice = Math.abs(diceDiff);

			var scoreChange = rollSum(dice);
			if (diceDiff < 0)
				scoreChange = -scoreChange;
			self.changeScore(scoreChange);
		}
		self.mode(mode);
	};
}

function AddPc(name, reaction, intuition, bonusInitiativeDice, dataProcessing, firewall) {
	var pc = new Npc(name, new NpcAttributes(0, 0, reaction, 0, 0, 0, intuition, 0, 0, 0, 0), 0, {}, [], bonusInitiativeDice, dataProcessing, firewall, []);
	pc.isPC = true
	return pc;
}

function NpcAttributes(body, agility, reaction, strength, willpower, logic, intuition, charisma, edge, magic, essence) {
	var self = this;
	self.body = body;
	self.agility = agility;
	self.reaction = reaction;
	self.strength = strength;
	self.willpower = willpower;
	self.logic = logic;
	self.intuition = intuition;
	self.charisma = charisma;
	self.edge = edge;
	self.magic = magic;
	self.essence = essence;
}

function Npc(name, attributes, armor, skills, guns, bonusInitiativeDice, dataProcessing, firewall, meleeWeapons, inactive) {
	//console.log('Creating npc ' + name);
	var self = this;
	self.name = name;
	self.attributes = attributes;
	self.body = ko.observable(attributes.body);
	self.agility = ko.observable(attributes.agility);
	self.reaction = ko.observable(attributes.reaction);
	self.strength = ko.observable(attributes.strength);
	self.willpower = ko.observable(attributes.willpower);
	self.logic = ko.observable(attributes.logic);
	self.intuition = ko.observable(attributes.intuition);
	self.charisma = ko.observable(attributes.charisma);
	self.edge = ko.observable(attributes.edge);
	self.magic = ko.observable(attributes.magic);
	self.essence = ko.observable(attributes.essence);
	self.dataProcessing = ko.observableIncremental(dataProcessing);
	self.firewall = ko.observableIncremental(firewall);
	self.armor = armor;
	self.recoilCompensation = ko.computed(function() { return Math.ceil(self.strength() / 3) + 1; });
	self.skills = new SkillArray(skills);
	self.statuses = ko.observableArray([]);
	self.isActive = ko.observable(false);
	self.selected = ko.observable(false);
	self.hasActed = ko.observable(false);
	self.isPC = false;
	self.edging = ko.observable(false);
	self.edgePoints = ko.observable(self.edge());
	self.useEdge = function() {
		if (!self.edging() || self.edgePoints() == 0) return 0;
		self.edgePoints(self.edgePoints() - 1);
		if (self.edgePoints() == 0) self.edging(false);
		return self.edge();
	};
	self.counterSpellPool = ko.computedResetable(function() { return self.skills.counterSpelling; }, 0);
	self.sustains = ko.observableIncremental(0);
	self.globalModifier = ko.computed(function() {
		var mod = self.sustains() * -2;
		mod += self.edgePoints() > 0 && self.edging() ? self.edge() : 0;
		return mod;
	});
	self.newCombatTurn = function() {
		self.counterSpellPool.used(0);
	};

	var sumModifiers = function(prop) {
		var sum = 0;
		for (var i = 0; i < self.statuses().length; i++) {
			for (var x = 0; x < arguments.length; x++) {
				if (self.statuses()[i] == arguments[x]) {
					sum += self.statuses()[i][prop];
				}
			}
		}
		return sum;
	};

	var ConditionTrack = function(attribute) {
		var self2 = this;
		self2.damage = ko.observable(0);
		self2.monitor = ko.computed(function() { return Math.ceil(attribute / 2) + 8; });
		self2.current = ko.computed(function() { return self2.monitor() - self2.damage(); });
		self2.takeDamage = function() { if (self2.damage() < self2.monitor()) self2.damage(self2.damage() + 1); };
		self2.healDamage = function() { if (self2.damage() > 0) self2.damage(self2.damage() - 1); };
		self2.label = ko.computed(function() {
			return 'Condition Monitor ' + self2.current() + '(' + self2.monitor() + ')';
		});
	};

	self.physicalTrack = new ConditionTrack(self.body());
	self.useStun = ko.observable(false);
	self.stunTrack = new ConditionTrack(self.willpower());

	self.unconcious = ko.computed(function() {
		var fromPhysical = self.physicalTrack.current() == 0;
		var fromStun = self.stunTrack.current() == 0;
		return fromPhysical || fromStun;
	});

	self.inactive = ko.observable(inactive === true);
	self.disabled = ko.computed(function() {
		var a = self.inactive();
		var b = self.unconcious();
		return a || b;
	});

	self.conditionModifier = ko.computed(function() {
		var fromDamage = Math.floor(self.physicalTrack.damage() / 3);
		var fromStun = Math.floor(self.stunTrack.damage() / 3);
		if (!self.useStun()) fromStun = 0;
		return -(fromDamage + fromStun);
	});

	self.initiative = new Initiative(self.reaction, self.intuition, bonusInitiativeDice, self.dataProcessing, self.conditionModifier);

	self.miscDefenseMod = ko.observable(0);
	self.lowerDefense = function() { self.miscDefenseMod(self.miscDefenseMod() - 1); };
	self.raiseDefense = function() { self.miscDefenseMod(self.miscDefenseMod() + 1); };
	self.previouslyDefendedAttacks = ko.observable(0);
	self.defense = ko.computed(function() { 
		return self.reaction() + self.intuition() + self.globalModifier() + self.miscDefenseMod() + self.conditionModifier() - self.previouslyDefendedAttacks(); 
	});
	self.startTurn = function() {
		self.isActive(true);
		self.previouslyDefendedAttacks(0);
	};
	self.endTurn = function() {
		self.isActive(false);
		self.hasActed(true);
	};
	self.gunDefense = ko.computed(function() {
		return self.defense() + 
			sumModifiers("defenseMod",
				Status.InMovingVehicle,
				Status.Prone,
				Status.Running,
				Status.GoodCover,
				Status.PartialCover,
				Status.InMelee);
	});
	self.meleeDefense = ko.computed(function() {
		return self.defense() + 
			sumModifiers("defenseMod",
				Status.InMovingVehicle,
				Status.ReceivingCharge,
				Status.GoodCover,
				Status.PartialCover);
	});
	self.spellcasting = ko.computed(function() {
		return self.skills.spellcasting + self.magic() + self.globalModifier() + self.conditionModifier();
	});

	var DefenseFireMode = function(mode) {
		var self2 = this;
		self2.mode = mode;
		self2.modifier = ko.computed(function() {
			return self.gunDefense() + self2.mode.defenseMod;
		});
		self2.label = ko.computed(function() {
			return self2.mode.name + ' ' + self2.modifier() + '(' + self2.mode.defenseMod + ')';
		});
	};
	self.defenseFireModes = [];
	var fireModes = FireMode.asArray();
	for (var i in fireModes) {
		self.defenseFireModes.push(new DefenseFireMode(fireModes[i]));
	}

	self.resistanceMiscModifier = ko.observable(0);
	self.resistance = ko.computed(function() { return self.armor + self.body() + self.resistanceMiscModifier() + self.globalModifier() });
	self.lowerResistance = function() { self.resistanceMiscModifier(self.resistanceMiscModifier() - 1); };
	self.raiseResistance = function() { self.resistanceMiscModifier(self.resistanceMiscModifier() + 1); };

	self.progressiveRecoil = ko.observable(0);
	self.resetRecoil = function() {
		self.progressiveRecoil(0);
	};

	self.statusModifier = function(status, modifier) {
		for (var i = 0; i < self.statuses().length; i++) {
			if (self.statuses()[i] == status)
				return modifier ? modifier : status.value;
		}
	};

	self.rangedAttackStatusModifier = ko.computed(function() {
		return sumModifiers("attackMod",
			Status.BlindFire,
			Status.BlindFireWithImaging,
			Status.InMelee,
			Status.Running,
			Status.CalledShot,
			Status.SmartGun,
			Status.ImplantedSmartGun,
			Status.LaserSight);
	});

	self.meleeAttackModifiers = ko.computed(function() {
		return sumModifiers("attackMod",
			Status.Charging,
			Status.Prone,
			Status.CalledShot,
			Status.SuperiorPosition,
			Status.FriendsInMelee,
			Status.TouchOnly);
	});

	self.removeDefenseModifier = function(modifier) {		
		if (self.statuses.indexOf(modifier) != -1) {
			self.statuses.remove(modifier);
		}
	};

	self.addDefenseModifier = function(modifier) {		
		if (self.statuses.indexOf(modifier) == -1) {
			self.statuses.push(modifier);
		}
	};

	self.toggleDefenseModifier = function(modifier) {
		if (self.statuses.indexOf(modifier) != -1) {
			self.statuses.remove(modifier);
			return false;
		}
		self.statuses.push(modifier);
		return true;
	};

	self.shoot = function(gun, fireMode) {
		var dicePool = fireMode.modifier();
		if (fireMode.mode.causesProgressiveRecoil) {
			self.progressiveRecoil(self.progressiveRecoil() + fireMode.mode.bulletsUsed);
		}

		gun.usedAmmo(gun.usedAmmo() + fireMode.mode.bulletsUsed);

		return dicePool;
	};

	self.gunDefend = function(fireMode) {
		var dicePool = fireMode.modifier();
		self.previouslyDefendedAttacks(self.previouslyDefendedAttacks() + 1);
		return dicePool;
	};

	self.meleeDefend = function() {
		var dicePool = self.meleeDefense();
		self.previouslyDefendedAttacks(self.previouslyDefendedAttacks() + 1);
		return dicePool;
	};

	self.guns = ko.observableArray([]);
	self.addGun = function(gun) {
		self.guns.push(gun);
		gun.setNpc(self);
	};
	for (var i in guns) {
		self.addGun(guns[i]);
	}

	self.meleeWeapons = ko.observableArray([]);
	self.addMeleeWeapon = function(meleeWeapon) {
		self.meleeWeapons.push(meleeWeapon);
		meleeWeapon.setNpc(self);
	};
	for (var i in meleeWeapons) {
		self.addMeleeWeapon(meleeWeapons[i]);
	}

	var MatrixDefense = function(name, attribute1, attribute2) {
		var self2 = this;
		self2.name = name;
		self2.modifier = ko.computed(function() {
			return attribute2() + attribute1() + self.conditionModifier() + self.initiative.hotSimModifier() + self.miscMatrixDefense();
		});
		self2.label = ko.computed(function () {
			return self2.name + ' ' + self2.modifier();
		});
	};

	self.miscMatrixDefense = ko.observable(0);
	self.matrixDefenses = [
		new MatrixDefense('Brute Force', self.willpower, self.firewall),
		new MatrixDefense('Hack On The Fly', self.intuition, self.firewall),
		new MatrixDefense('Hide', self.intuition, self.dataProcessing),
		new MatrixDefense('Perception', self.logic, self.logic), // todo: slease
		new MatrixDefense('Snoop', self.logic, self.firewall),
		new MatrixDefense('Trace', self.willpower, self.willpower) // todo: slease
	];
	self.matrixDefenses.lower = function() { self.miscMatrixDefense(self.miscMatrixDefense() - 1); };
	self.matrixDefenses.raise = function() { self.miscMatrixDefense(self.miscMatrixDefense() + 1); };
	self.matrixResistance = ko.computed(function() {
		return self.firewall() + self.firewall() + self.globalModifier(); // todo: device rating
	});

	self.clone = function() {
		var guns = [];
		for (var i in self.guns()) {
			guns.push(self.guns()[i].clone());
		}
		var meleeWeapons = [];
		for (var i in self.meleeWeapons()) {
			meleeWeapons.push(self.meleeWeapons()[i].clone());
		}
		return new Npc(name, attributes, armor, skills, guns, 
			bonusInitiativeDice, dataProcessing, firewall, meleeWeapons);
	};

	self.cloneMany = function(count) {
		var npcs = [];
		for (var i = 1; i <= count; i++) {
			var npc = self.clone();
			npc.name = npc.name.replace(/\{0\}/, i);
			npcs.push(npc);
		}
		return npcs;
	};
	console.log('Created npc ' + name);
}

function MeleeWeapon(name, accuracy, reach, damage, damageType, armorPenetration, linkedSkill) {
	var self = this;
	self.name = name;
	self.accuracy = accuracy;
	self.reach = reach;
	self.damage = damage;
	self.damageType = damageType;
	self.armorPenetration = armorPenetration;
	self.linkedSkill = linkedSkill;
	self.miscModifier = ko.observableIncremental(0);

	self.setNpc = function(npc) {
		self.modifier = ko.computed(function() {
			return npc.agility() + 
				npc.skills[self.linkedSkill] + 
				npc.conditionModifier() + 
				npc.meleeAttackModifiers() + 
				npc.globalModifier() + 
				self.miscModifier();
		});
		self.damageValue = ko.computed(function() { return npc.strength() + self.damage });
	};

	self.clone = function() {
		return new MeleeWeapon(name, accuracy, reach, damage, damageType, armorPenetration, linkedSkill);
	};
}

function Gun(name, accuracy, damage, damageType, armorPenetration, fireModes, recoilCompensation, maxAmmo, linkedSkill, hasSmartLink) {
	var self = this;
	self.name = name;
	self.accuracy = accuracy;
	self.damage = damage;
	self.damageType = damageType;
	self.armorPenetration = armorPenetration;
	self.recoilCompensation = recoilCompensation;
	self.maxAmmo = maxAmmo;
	self.usedAmmo = ko.observable(0);
	self.ammo = ko.computed(function() { return self.maxAmmo - self.usedAmmo(); });
	self.reload = function() {
		self.usedAmmo(0);
	};
	self.deviceRating = 2;
	self.linkedSkill = linkedSkill;
	self.miscModifier = ko.observableIncremental(0);
	self.smartLinkOn = ko.observable(true);
	self.hasSmartLink = hasSmartLink;

	self.smartLinkModifier = ko.observable(self.hasSmartLink ? 2 : 0);
	self.toggleSmartLink = function() {
		switch (self.smartLinkStatus())
		{
			case 'Implanted':
				self.smartLinkStatus('Worn');
				self.smartLinkModifier(1);
				break;
			case 'Worn':
				self.smartLinkStatus('Off');
				self.smartLinkModifier(0);
				break;
			default:
				self.smartLinkStatus('Implanted');
				self.smartLinkModifier(2);
		}
	};
	self.smartLinkStatus = ko.observable('Implanted');
	self.smartLinkLabel = ko.computed(function() {
		return 'SmartLink ' + self.smartLinkStatus();
	});

	self.clone = function() {
		return new Gun(name, accuracy, damage, damageType, armorPenetration, fireModes, recoilCompensation, maxAmmo, linkedSkill);
	};

	self.setNpc = function(npc) {
		self.modifier = ko.computed(function() {
			return npc.agility() + 
				npc.skills[self.linkedSkill] + 
				npc.conditionModifier() + 
				npc.rangedAttackStatusModifier() +
				npc.globalModifier() +
				self.smartLinkModifier() +
				self.miscModifier();
		});

		self.totalRecoilCompensation = ko.computed(function() { return npc.recoilCompensation() + self.recoilCompensation; });
		self.progressiveRecoil = ko.computed(function() { return self.totalRecoilCompensation() - npc.progressiveRecoil(); });
		self.recoilLabel = ko.computed(function() { return self.progressiveRecoil() + ' ' + (self.progressiveRecoil() >= 0 ? 'rc' : 'pr'); });

		var GunFireMode = function(mode) {
			var self2 = this;
			self2.mode = mode;
			self2.modifier = ko.computed(function() {
				var recoilCompensation = self2.mode.causesProgressiveRecoil ? self.progressiveRecoil() : self.totalRecoilCompensation();
				var progressiveRecoil = recoilCompensation - self2.mode.bulletsUsed;
				if (progressiveRecoil >= 0) return self.modifier();
				return self.modifier() + progressiveRecoil;
			});
			self2.label = ko.computed(function() {
				return mode.name + ' ' + self2.modifier() + '(-' + mode.bulletsUsed + ')'
			});
		};
		self.fireModes = [];
		for (var i in fireModes) {
			self.fireModes.push(new GunFireMode(fireModes[i]));
		}
	};
}

//function Gun(name, accuracy, damage, damageType, armorPenetration, fireModes, recoilCompensation, maxAmmo, linkedSkill) {
var Guns = {
	AresPredatorV: function () { return new Gun('Ares Predator V', 5, 8, 'P', -1, [FireMode.SA,FireMode.SB], 0, 15, 'pistols', true); },
	BrowningUltraPower: function () { return new Gun('Browning Ultra-Power', 6, 8, 'P', -1, [FireMode.SA,FireMode.SB], 0, 10, 'pistols'); },
	RugerSuperWarhawk: function () { return new Gun('Ruger Super Warhawk', 5, 9, 'P', -2, [FireMode.SS], 0, 6, 'pistols'); },
	ColtGovernment2066: function () { return new Gun('Colt Government 2066', 6, 7, 'P', -1, [FireMode.SA,FireMode.SB], 0, 11, 'pistols'); },
	ColtAmericaL36: function () { return new Gun('Colt America L36', 7, 7, 'P', 0, [FireMode.SA,FireMode.SB], 0, 14, 'pistols'); },
	ColtCobraTZ120: function () { return new Gun('Colt Cobra TZ-120', 5, 7, 'P', 0, [FireMode.SA,FireMode.BF,FireMode.FA], 3, 32, 'automatics'); },
	AK97: function () { return new Gun('AK-97', 5, 10, 'P', -2, [FireMode.SA,FireMode.BF,FireMode.FA], 0, 38, 'automatics'); },
	Bow: function (rating) { return new Gun('Bow ' + rating, 6, rating + 2, 'P', -Math.ceil(rating / 4), [FireMode.SS], 0, 99, 'automatics'); },
	DefianceT250: function () { return new Gun('Defiance T-250', 4, 10, 'P', -1, [FireMode.SS,FireMode.SA,FireMode.SB], 0, 5, 'longArms'); },
	IngramValiant: function () { return new Gun('Ingram Valiant', 6, 9, 'P', -2, [FireMode.BF,FireMode.FA], 3, 100, 'automatics'); },
	AresAlpha: function () { return new Gun('Ares Alpha', 7, 11, 'P', -2, [FireMode.SA,FireMode.BF,FireMode.FA], 2, 42, 'automatics'); },
};

//function MeleeWeapon(name, accuracy, reach, damage, damageType, armorPenetration, linkedSkill) {
var MeleeWeapons = {
	Club: function() { return new MeleeWeapon('Club', 4, 1, 3, 'P', -1, 'clubs') },
	Unarmed: function() { return new MeleeWeapon('Unarmed', 7, 0, 0, 'S', 0, 'unarmed') }, // fix accuracy
	Knife: function() { return new MeleeWeapon('Knife', 5, 0, 1, 'P', -1, 'blades') },
	CombatKnife: function() { return new MeleeWeapon('Combat Knife', 6, 0, 2, 'P', -3, 'blades') },
	Sword: function() { return new MeleeWeapon('Sword', 6, 1, 3, 'P', -2, 'blades') },
	ThrowingKnife: function() { return new MeleeWeapon('Throwing Knife', 6, 0, 1, 'P', -1, 'blades') },
	Claws: function() { return new MeleeWeapon('Claws', 8, 0, 3, 'P', -1, 'unarmed') },
	Horns: function() { return new MeleeWeapon('Horns', 8, 1, 5, 'P', 0, 'unarmed') },
	Bite: function(damage) { return new MeleeWeapon('Horns', 8, 1, damage, 'P', 0, 'unarmed') },
	Natural: function(damage) { return new MeleeWeapon('Natural', 8, 0, damage, 'P', 0, 'unarmed') },
	Knucks: function() { return new MeleeWeapon('Knucks', 7, 0, 1, 'P', 0, 'unarmed')} // fix accuracy
};

function log(success, msg) {
	if (success !== true && success !== false) {
		msg = success;
		success = true;
	}

	if (success) alertify.success(msg);
	else alertify.error(msg);

	if (msg.replace) msg = msg.replace("<br/>", "\r\n");
	console.log(msg);
};

function CharacterPaneView() {
	var self = this;
	self.character = ko.observable();
	self.actionMode = ko.observable();
}

function AppViewModel() {
	var self = this;
	self.newEncounterName = ko.observable('');
	self.savedEncounters = ko.observableArray([]);
	self.selectedEncounter = ko.observable();
	self.characterPane = new CharacterPaneView();
	self.selectCharacter = function(action, character) {
		self.characterPane.character(character);
		self.characterPane.actionMode(action);
	};
	self.actionModes = [
		'Matrix',
		'Attack',
		'Defend',
		'Magic',
	];
	self.changeInitiativeScore = function(character, scoreChange) {
		character.initiative.changeScore(scoreChange);
	};
	self.mode = ko.observable('game');
	self.changeMode = function(mode) {
		self.mode(mode);
	};

	self.newPCName = ko.observable();
	self.newPCReaction = ko.observable();
	self.newPCIntuition = ko.observable();
	self.newPCInitDice = ko.observable();
	self.newPCDataProcessing = ko.observable();
	self.newPCFirewall = ko.observable();
	self.addPlayerCharacter = function() {
		var pc = AddPc(self.newPCName(), parseInt(self.newPCReaction()), parseInt(self.newPCIntuition()), parseInt(self.newPCInitDice()), 
			parseInt(self.newPCDataProcessing()), parseInt(self.newPCFirewall()));
		pc.initiative.roll();
		pc.initiative.changeScore(-(self.initiativePassCounter() - 1) * 10)
		self.npcs.push(pc);
		self.npcs.sort(sortByInitiative);
		self.changeMode('game');
	};

	self.deactivateCharacter = function(npc) {
		npc.inactive(true);
	};

	self.activateCharacter = function(npc) {
		npc.inactive(false);
	};

	var encounters = JSON.parse(localStorage.getItem('encounters'));
	if (encounters) {
		for (var i in encounters) {
			self.savedEncounters.push({name: i, value: encounters[i]});
		}
	}

//function Npc(name, attributes, armor, skills, guns, bonusInitiativeDice, dataProcessing, firewall, meleeWeapons) {
//function NpcAttributes(body, agility, reaction, strength, willpower, logic, intuition, charisma, edge, magic, essence) {
	self.npcs = ko.observableArray([]);
	if (location.href.indexOf('#') != -1) {
		var compressedEncounter = location.href.substring(location.href.indexOf('#')+1);
		self.loadCompressedEncounter(compressedEncounter);
	}
	else if (location.href.indexOf('test') != -1) {
		self.npcs([
			new Npc('Vincenzo "Vic" Fratelli', 
				new NpcAttributes(5, 5, 4, 4, 4, 3, 4, 4, 1, 0, 5), 10,
				{unarmed: 2, pistols: 3}, 
				[Guns.AresPredatorV()], 0, 3, 3, [MeleeWeapons.Knucks()]),
			new Npc('Franco "Frank" Fratelli', 
				new NpcAttributes(4, 4, 3, 3, 5, 4, 3, 4, 1, 5, 6), 8,
				{unarmed: 2, pistols: 2, spellcasting: 2}, 
				[Guns.ColtAmericaL36()], 0, 3, 3, [MeleeWeapons.Unarmed()], true),
			new Npc('Demetrio "Dipsy" Fratelli',
				new NpcAttributes(4, 3, 4, 5, 2, 2, 2, 3, 1, 0, 5.9), 10,
				{unarmed: 2, pistols: 3, clubs: 4},
				[Guns.ColtAmericaL36()], 0, 3, 3, [MeleeWeapons.Unarmed(), new MeleeWeapon('Mop', 4, 2, 8, 'S', 0, 'clubs')]),
			new Npc('Patrizo "Patsy" Fratelli', 
				new NpcAttributes(4, 4, 4, 3, 3, 4, 3, 3, 1, 0, 6), 8,
				{unarmed: 3, pistols: 3, computer: 3, hacking: 3, perception: 3}, 
				[Guns.AresPredatorV()], 0, 4, 5, [MeleeWeapons.Unarmed()]),
			new Npc('Luciano "Lucy" Fratelli', 
				new NpcAttributes(5, 4, 3, 6, 4, 3, 4, 3, 1, 0, 4.5), 12,
				{unarmed: 3, pistols: 3}, 
				[Guns.ColtGovernment2066()], 0, 3, 3, [MeleeWeapons.Knucks()]),
//function MeleeWeapon(name, accuracy, reach, damage, damageType, armorPenetration, linkedSkill) {
		]);
	}
	else if (location.href.indexOf('02') != -1) {
		self.npcs([new Npc('Defense Turret', new NpcAttributes(6, 4, 4, 12, 4, 4, 4, 4, 0, 0, 0), 12, {automatics: 4}, [Guns.IngramValiant()], 3, 4, 4, [])]);
	}
	else if (location.href.indexOf('03') != -1) {
		self.npcs(new Npc('Hellhound Ganger', new NpcAttributes(4, 4, 4, 4, 3, 2, 3, 3, 1, 0, 6), 10, {unarmed: 3, blades: 4, pistols: 4}, [Guns.BrowningUltraPower()], 
			1, 3, 3, [MeleeWeapons.Knife()]).cloneMany(12));
	}
	else if (location.href.indexOf('04') != -1) {
		self.npcs([
			new Npc('Gunner 1', new NpcAttributes(4, 6, 6, 5, 5, 2, 4, 3, 3, 0, 6), 0, {unarmed: 6, automatics: 6, blades: 5}, [Guns.AresAlpha()], 3, 0, 0, [MeleeWeapons.CombatKnife()]), 
			new Npc('Gunner 2', new NpcAttributes(4, 6, 6, 5, 5, 2, 4, 3, 3, 0, 6), 0, {unarmed: 6, automatics: 6, blades: 5}, [Guns.AresAlpha()], 3, 0, 0, [MeleeWeapons.CombatKnife()]),
			new Npc('Sniper', new NpcAttributes(4, 6, 6, 5, 5, 2, 4, 3, 3, 0, 6), 0, {unarmed: 6, automatics: 6, blades: 5}, [Guns.AresAlpha()], 3, 0, 0, [MeleeWeapons.CombatKnife()]),
			new Npc('Mage', new NpcAttributes(4, 6, 6, 5, 5, 2, 4, 3, 3, 0, 6), 0, {unarmed: 6, automatics: 6, blades: 5}, [Guns.AresAlpha()], 3, 0, 0, [MeleeWeapons.CombatKnife()])
		]);
	}

//function AddPc(name, reaction, intuition, bonusInitiativeDice, dataProcessing, firewall) {
	self.npcs.push(AddPc('Gunther', 4, 4, 0, 4, 4));
	self.npcs.push(AddPc('Odder', 4, 5, 0, 2, 2));
	self.npcs.push(AddPc('SIMaeon', 2, 5, 0, 4, 3));
	self.npcs.push(AddPc('Takashi', 6, 4, 1, 6, 6));
	self.npcs.push(AddPc('Roto Drone', 7, 3, 1, 6, 6));
	self.npcs.push(AddPc('Roto Drone', 7, 3, 1, 6, 6));

	self.selectCharacter('Attack', self.npcs()[0]);

	self.activeNpcs = ko.computed(function() {
		return ko.utils.arrayFilter(self.npcs(), function(npc) {
			return !npc.disabled();
		});
	});

	self.disabledNpcs = ko.computed(function() {
		return ko.utils.arrayFilter(self.npcs(), function(npc) {
			return npc.disabled();
		});
	});

	self.attackModifiers = Status.attackModifiers();
	self.defenseModifiers = Status.defenseModifiers();
	self.fireModes = FireMode.asArray();

	var generalOutput = function(desc, diceResult) {
		var msg = desc + '.';
		if (diceResult.glitch) {
			msg += 'Glitch.';
		}
		msg += '<br/>';
		if (diceResult.explodeDice > 0) {
			msg += diceResult.explodeDice + ' exploded.<br/>';
		}
		msg += diceResult.dice + ' dice / ' + diceResult.hits + ' hits';
		log(!diceResult.glitch,msg);
	};

	var sortByInitiative = function(a, b) {
		if (a.initiative.score() > b.initiative.score()) return -1;
		if (a.initiative.score() < b.initiative.score()) return 1;
		if (a.initiative.modifier() > b.initiative.modifier()) return -1;
		if (a.initiative.modifier() < b.initiative.modifier()) return 1;
		if (a.name > b.name) return -1;
		return 1;
	};

	self.initiativePassCounter = ko.observable(1);
	self.startCombatTurn = function() {
		log("Starting new combat turn");
		for (var i in self.npcs()) {
			self.npcs()[i].initiative.roll();
			self.npcs()[i].hasActed(false);
			self.npcs()[i].isActive(false);
			self.npcs()[i].newCombatTurn();
		}
		self.npcs.sort(sortByInitiative);
		self.initiativePassCounter(1);
		self.activeNpcs()[0].startTurn();
		//$.scrollTo('.character:eq(0)', 300);
	};

	self.startNextInitiativePass = function() {
		log("Starting new initiative pass");
		for (var i in self.npcs()) {
			self.npcs()[i].initiative.changeScore(-10);
			if (self.npcs()[i].initiative.score() > 0) {
				self.npcs()[i].hasActed(false);
			}
		}
		self.activeNpcs()[0].startTurn();
		self.initiativePassCounter(self.initiativePassCounter() + 1);
		//$.scrollTo('.character:eq(0)', 300);
	};

	self.endTurn = function() {
		for (var i = 0; i < self.npcs().length; i++) {
			if (self.npcs()[i].isActive()) {
				self.npcs()[i].endTurn();
			}
		}
		self.npcs.sort(sortByInitiative);

		var anyCanActThisPass = false;
		var anyCanActNextPass = false;
		for (var i = 0; i < self.activeNpcs().length; i++) {
			var npc = self.activeNpcs()[i];
			if (!npc.hasActed() && npc.initiative.score() > 0) {
				anyCanActThisPass = true;
				npc.startTurn();
				//$.scrollTo('.character:eq(' + i +')', 300);
				break;
			}
			if (npc.initiative.score() > 10) {
				anyCanActNextPass = true;
			}
		}

		if (!anyCanActThisPass) {
			if (anyCanActNextPass) {
				self.startNextInitiativePass();
			}
			else {
				self.startCombatTurn();
			}
		}
	}

	self.rollMatrixDefense = function(npc, matrixDefense) {
		var dicePool = matrixDefense.modifier();
		generalOutput('Matrix Defense', roll(dicePool, npc.useEdge()));
	};

	self.rollGunDefense = function(npc, fireMode) {
		var dicePool = npc.gunDefend(fireMode);
		generalOutput('Defense', roll(dicePool, npc.useEdge()));
	};

	self.rollMeleeDefense = function(npc) {
		var dicePool = npc.meleeDefend();
		generalOutput('Defense', roll(dicePool, npc.useEdge()));
	};

	self.rollResistance = function(npc) {
		generalOutput('Resistance', roll(npc.resistance(), npc.useEdge()));
	};

	self.rollMatrixResistance = function(npc) {
		generalOutput('Matrix Resistance', roll(npc.matrixResistance(), npc.useEdge()));
	};

	self.shoot = function(npc, gun, mode) {
		var diceResults = roll(npc.shoot(gun, mode), npc.useEdge());
		generalOutput(gun.name + ' ' + mode.mode.name + '<br/>' + gun.damage + gun.damageType + ' DV ' + gun.accuracy + ' acc', diceResults);
	};

	self.rollMeleeAttack = function(npc, meleeWeapon) {
		var diceResults = roll(meleeWeapon.modifier(), npc.useEdge());
		generalOutput(meleeWeapon.name + '<br/>' + meleeWeapon.damageValue() + meleeWeapon.damageType + ' DV ' + meleeWeapon.accuracy + ' acc', diceResults);
	};

	self.rollSpellcasting = function(npc) {
		var diceResults = roll(npc.spellcasting(), npc.useEdge());
		generalOutput('Spellcasting', diceResults);
	};

	self.toggleDefenseModifier = function(npc, modifier, event) {
		var $target = $(event.target);

		if (npc.toggleDefenseModifier(modifier)) {
			$target.addClass('on');
		}
		else {
			$target.removeClass('on');
		}
	}
}

function rollSum(dice) {
	var sum = 0;
	for (var i = 0; i < dice; i++) {
		sum += Math.floor((Math.random() * 6) + 1);
	}
	return sum;
}

function roll(dice, explode) {
	var dice = dice < 0 ? 0 : dice;
	var hits = 0;
	var ones = 0;
	var explodeDice = 0;
	for (var i = 0; i < dice + explodeDice; i++) {
		var result = Math.floor((Math.random() * 6) + 1);
		if (result < 1 || result > 6) alert ('Dice roll was out of range. ' + result);
		if (result == 1) ones++;
		if (result >= 5) hits++;
		if (result == 6 && explode) explodeDice++;
	}
	var rollResult = { dice: dice, explodeDice: explodeDice, hits: hits };
	if (ones > (dice + explodeDice) / 2) {
		rollResult.glitch = true;
		return rollResult;
	}
	return rollResult;
}

// Activates knockout.js
$(function() {
	window.m = new AppViewModel();
	ko.applyBindings(window.m);
});
</script>
</head>

<body>
<div data-bind="visible: mode() == 'addpc'">
<h1>New Pc</h1>
<input type="text" placeholder="Name" data-bind="value: newPCName" />
<input type="text" placeholder="Reaction" data-bind="value: newPCReaction" />
<input type="text" placeholder="Intuition" data-bind="value: newPCIntuition" />
<input type="text" placeholder="Bonus Init Dice" data-bind="value: newPCInitDice" />
<input type="text" placeholder="Data Processing" data-bind="value: newPCDataProcessing" />
<input type="text" placeholder="Firewall" data-bind="value: newPCFirewall" />
<button data-bind="click: addPlayerCharacter">Add</button> <button data-bind="click: function() { changeMode('game') }">Cancel</button>
</div>
<div data-bind="visible: mode() == 'game'">
	<button data-bind="click: startCombatTurn">New Combat Turn</button>
	<input type="text" data-bind="value: newEncounterName" />
	<span data-bind="visible: savedEncounters().length > 0">
		<select data-bind="options: savedEncounters, optionsText: 'name', value: selectedEncounter"></select>
		<button data-bind="click: function() { changeMode('addpc') }">Add PC</button>
	</span>
</div>
<div data-bind="with: characterPane.character, visible: mode() == 'game'">
<div class="character" data-bind="css: { npc: !isPC, pc: isPC, selected: selected }">
	<h1 class="character-name"><span data-bind="text: name"></span>; <span class="initiative" data-bind="text: initiative.label()"></span></h1>
	<ul class="statline title">
		<li>B</li>
		<li>A</li>
		<li>R</li>
		<li>S</li>
		<li>W</li>
		<li>L</li>
		<li>I</li>
		<li>C</li>
		<li>Ess</li>
		<li>E</li>
		<li>M</li>
		<li class="incremental" data-bind="event: {contextmenu: dataProcessing.lower}, click: dataProcessing.raise">DP</li>
		<li class="incremental" data-bind="event: {contextmenu: firewall.lower}, click: firewall.raise">FW</li>
	</ul>
	<ul class="statline">
		<li data-bind="text: body"></li>
		<li data-bind="text: agility"></li>
		<li data-bind="text: reaction"></li>
		<li data-bind="text: strength"></li>
		<li data-bind="text: willpower"></li>
		<li data-bind="text: logic"></li>
		<li data-bind="text: intuition"></li>
		<li data-bind="text: charisma"></li>
		<li data-bind="text: essence"></li>
		<li data-bind="text: edge"></li>
		<li data-bind="text: magic"></li>
		<li data-bind="text: dataProcessing"></li>
		<li data-bind="text: firewall"></li>
	</ul>
	<div class="end-turn">
		<span data-bind="foreach: initiative.otherModes">
			<button data-bind="text: $data, click: $parent.initiative.changeMode"></button>
		</span>
		<button data-bind="click: function() { $root.changeInitiativeScore($data, -5); }">-5</button>
		<button data-bind="click: function() { $root.changeInitiativeScore($data, -10); }">-10</button>
		<button data-bind="click: $root.endTurn">End Turn</button>
	</div>
<!-- condition -->
	<div class="action-grp">
		<button data-bind="text: physicalTrack.label(), event: {contextmenu: physicalTrack.healDamage}, click: physicalTrack.takeDamage"></button>
		<button data-bind="visible: useStun, text: stunTrack.label(), event: {contextmenu: stunTrack.healDamage}, click: stunTrack.takeDamage"></button>
		<label><input type="checkbox" data-bind="checked: useStun" />Stun</label>
		<label data-bind="visible: edgePoints() > 0"><input type="checkbox" data-bind="checked: edging" />Edging(<span data-bind="text: edgePoints"></span>)</label>
	</div>
	<div data-bind="visible: !isPC">
<!-- defense -->
		<div class="action-grp" data-bind="visible: $root.characterPane.actionMode() == 'Defend'">
			<button data-bind="text: 'Defense ' + defense() + '(' + miscDefenseMod() + ')', event: {contextmenu: lowerDefense}, click: raiseDefense"></button>
			<span data-bind="foreach: defenseFireModes" class="action-grp">
				<button class="fixed-wide" data-bind="text: label, click: function() { $root.rollGunDefense($parent, $data); }"></button>
			</span>
			<button data-bind="text: 'Melee ' + meleeDefense(), click: $root.rollMeleeDefense"></button>
		</div>
<!-- magic -->
		<div class="action-grp" data-bind="visible: $root.characterPane.actionMode() == 'Magic'">
			<button data-bind="text: 'Sustains ' + sustains(), event: {contextmenu: sustains.lower}, click: sustains.raise"></button>
			<button data-bind="text: 'Counterspells ' + counterSpellPool(), event: {contextmenu: counterSpellPool.used.lower}, click: counterSpellPool.used.raise"></button>
			<button data-bind="text: 'Spellcasting ' + spellcasting(), click: function() { $root.rollSpellcasting($data); }"></button>
			<!--<button data-bind="text: 'Body Defense ' + physicalSpellDefense(), click: function() { $root.rollSpellcasting($data); }"></button>
			<button data-bind="text: 'Mana Defense ' + manaSpellDefense(), click: function() { $root.rollSpellcasting($data); }"></button>
			<button data-bind="text: 'W+L Defense ' + willLogicSpellDefense(), click: function() { $root.rollSpellcasting($data); }"></button>
			<button data-bind="text: 'L+I Defense ' + logicIntuitionSpellDefense(), click: function() { $root.rollSpellcasting($data); }"></button>-->
		</div>
<!-- matrix defense -->
		<div class="action-grp" data-bind="visible: $root.characterPane.actionMode() == 'Matrix'">
			<button data-bind="text: 'Matrix Mod ' + miscMatrixDefense(), event: {contextmenu: matrixDefenses.lower}, click: matrixDefenses.raise"></button>
			<span data-bind="foreach: matrixDefenses">
				<button data-bind="text: label, click: function() { $root.rollMatrixDefense($parent, $data); }"></button>
			</span>
		</div>
<!-- resistance -->
		<div class="action-grp" data-bind="visible: $root.characterPane.actionMode() == 'Defend'">
			<button data-bind="text: 'Physical Resistance Mod ' + resistance() + '(' + resistanceMiscModifier() + ')', 
				event: {contextmenu: lowerResistance}, click: raiseResistance"></button>
			<button data-bind="click: $root.rollResistance">Resist Physical Damage</button>
			<button data-bind="click: $root.rollMatrixResistance">Resist Matrix Damage</button>
<!--
			<button data-bind="text: 'Resist Magical ' + resistance() + '(' + resistanceMiscModifier() + ')', 
				event: {contextmenu: lowerResistance}, click: raiseResistance"></button>
			<button data-bind="text: 'Resist Magical'"></button>
-->
		</div>
<!-- guns -->
		<div class="action-grp" data-bind="foreach: guns, visible: $root.characterPane.actionMode() == 'Attack'">
			<div class="action-grp">
				<button class="gun-label" data-bind="text: name + ' ' + modifier() + '(' + miscModifier() + ')', click: miscModifier.raise, event: { contextmenu: miscModifier.lower }"></button>
				<span data-bind="foreach: fireModes">
					<button class="fixed-wide" data-bind="text: label, click: function() { $root.shoot($parents[1], $parent, $data); }"></button> 
				</span>
				<button data-bind="text: recoilLabel, click: $parent.resetRecoil"></button>
				<button data-bind="text: ammo() + ' ammo', click: reload"></button>
				<button class="smart-link-toggle" data-bind="visible: hasSmartLink, text: smartLinkLabel, click: toggleSmartLink"></button>
			</div>
		</div>
<!-- melee -->
		<div data-bind="foreach: meleeWeapons, visible: $root.characterPane.actionMode() == 'Attack'">
			<div class="action-grp">
				<button data-bind="text: name + ' ' + modifier() + '(' + miscModifier() + ')', click: miscModifier.raise, event: { contextmenu: miscModifier.lower }"></button>
				<button data-bind="click: function() { $root.rollMeleeAttack($parent, $data) }">Attack</button> 
			</div>
		</div>
<!-- defense mods -->
		<div class="defense-status-mods" data-bind="foreach: $root.defenseModifiers, visible: $root.characterPane.actionMode() == 'Defend'" class="action-grp">
			<div data-bind="text: $data.key + ' ' + $data.defenseMod, css: { on: false }, click: function(data, evt) { return $root.toggleDefenseModifier($parent, data, evt); }" class="modifier"></div>
		</div>
<!-- attack mods -->
		<div class="attack-status-mods" data-bind="foreach: $root.attackModifiers, visible: $root.characterPane.actionMode() == 'Attack'" class="action-grp">
			<div data-bind="text: $data.key + ' ' + $data.attackMod, css: { on: false }, click: function(data, evt) { return $root.toggleDefenseModifier($parent, data, evt); }" class="modifier"></div> 
		</div><br/>
	</div>
</div>
</div>

<div data-bind="foreach: activeNpcs, visible: mode() == 'game'">
	<div class="character-card" data-bind="css: { active: isActive, npc: !isPC, pc: isPC, selected: selected, canAct: initiative.score() > 0 }">
		<h1 class="character-name"><span data-bind="text: name"></span> <span class="initiative" data-bind="text: initiative.label()"></span></h1>		
		<div class="action-grp">
			<label data-bind="text: physicalTrack.label()"></label>
			<label data-bind="visible: useStun, text: stunTrack.label()"></label>
		</div>
		<div data-bind="foreach: $root.actionModes">
			<div class="action-icon" data-bind="text: $data, css: $data, click: function() { $root.selectCharacter($data, $parent) }"></div>
		</div>
		<div class="action-icon" data-bind="click: $root.deactivateCharacter">Disable</div>
	</div>
</div>

<br/>
<hr/>

<div class="disabled-characters">
<div data-bind="foreach: disabledNpcs, visible: mode() == 'game'">
	<div class="character-card" data-bind="css: { active: isActive, npc: !isPC, pc: isPC, selected: selected, canAct: initiative.score() > 0 }">
		<h1 class="character-name"><span data-bind="text: name"></span> <span class="initiative" data-bind="text: initiative.label()"></span></h1>		
		<div class="action-grp" data-bind="css: { unconcious: unconcious }">
			<label data-bind="text: physicalTrack.label()"></label>
			<label data-bind="visible: useStun, text: stunTrack.label()"></label>
		</div>
		<div data-bind="foreach: $root.actionModes">
			<div class="action-icon" data-bind="text: $data, css: $data, click: function() { $root.selectCharacter($data, $parent) }"></div>
		</div>
		<div class="action-icon" data-bind="click: $root.activateCharacter, visible: !unconcious()">Activate</div>
	</div>
</div>
<br/>
</div>
</body>

</html>